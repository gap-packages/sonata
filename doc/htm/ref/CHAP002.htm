<html><head><title>[SONATA] 2 Nearrings</title></head>
<body text="#000000" bgcolor="#ffffff">
[<a href = "chapters.htm">Up</a>] [<a href ="CHAP001.htm">Previous</a>] [<a href ="CHAP003.htm">Next</a>] [<a href = "theindex.htm">Index</a>]
<h1>2 Nearrings</h1><p>
<P>
<H3>Sections</H3>
<oL>
<li> <A HREF="CHAP002.htm#SECT001">Defining a nearring multiplication</a>
<li> <A HREF="CHAP002.htm#SECT002">Construction of nearrings</a>
<li> <A HREF="CHAP002.htm#SECT003">Direct products of nearrings</a>
<li> <A HREF="CHAP002.htm#SECT004">Operation tables for nearrings</a>
<li> <A HREF="CHAP002.htm#SECT005">Modified symbols for the operation tables</a>
<li> <A HREF="CHAP002.htm#SECT006">Accessing nearring elements</a>
<li> <A HREF="CHAP002.htm#SECT007">Nearring elements</a>
<li> <A HREF="CHAP002.htm#SECT008">Random nearring elements</a>
<li> <A HREF="CHAP002.htm#SECT009">Nearring generators</a>
<li> <A HREF="CHAP002.htm#SECT010">Size of a nearring</a>
<li> <A HREF="CHAP002.htm#SECT011">The additive group of a nearring</a>
<li> <A HREF="CHAP002.htm#SECT012">Nearring endomorphisms</a>
<li> <A HREF="CHAP002.htm#SECT013">Nearring automorphisms</a>
<li> <A HREF="CHAP002.htm#SECT014">Isomorphic nearrings</a>
<li> <A HREF="CHAP002.htm#SECT015">Subnearrings</a>
<li> <A HREF="CHAP002.htm#SECT016">Invariant subnearrings</a>
<li> <A HREF="CHAP002.htm#SECT017">Constructing subnearrings</a>
<li> <A HREF="CHAP002.htm#SECT018">Intersection of nearrings</a>
<li> <A HREF="CHAP002.htm#SECT019">Identity of a nearring</a>
<li> <A HREF="CHAP002.htm#SECT020">Units of a nearring</a>
<li> <A HREF="CHAP002.htm#SECT021">Distributivity in a nearring</a>
<li> <A HREF="CHAP002.htm#SECT022">Elements of a nearring with special properties</a>
<li> <A HREF="CHAP002.htm#SECT023">Special properties of a nearring</a>
</ol><p>
<p>
A <strong>(left) nearring</strong> is a nonempty set <i>N</i> together with two binary 
operations on <i>N</i>, + and &#183; s.t. (<i>N</i>,+) is a group, (<i>N</i>,&#183;) is 
a semigroup, and &#183; is left distributive over +, i.e. 
&#8704;<i>n</i><sub>1</sub>,<i>n</i><sub>2</sub>,<i>n</i><sub>3</sub>  &#8712; <i>N</i>:&nbsp;<i>n</i><sub>1</sub>&#183;(<i>n</i><sub>2</sub>+<i>n</i><sub>3</sub>) = <i>n</i><sub>1</sub>&#183;<i>n</i><sub>2</sub> + <i>n</i><sub>1</sub>&#183;<i>n</i><sub>3</sub>.
<p>
For more information we suggest <a href="biblio.htm#Pilz:Nearrings"><cite>Pilz:Nearrings</cite></a>,
<a href="biblio.htm#meldrum85:NATLWG"><cite>meldrum85:NATLWG</cite></a>, and <a href="biblio.htm#Clay:Nearrings"><cite>Clay:Nearrings</cite></a>.
<p>
The functions described in this section can be found in the source files
<code>nr.g?</code> and <code>nrconstr.g?</code>.
<p>
<p>
<h2><a name="SECT001">2.1 Defining a nearring multiplication</a></h2>
<p><p>
<a name = "SSEC001.1"></a>
<li><code>IsNearRingMultiplication( </code><var>G</var><code>, </code><var>mul</var><code>, [</code><var>lcs</var><code>] )</code>
<p>
The arguments of the function <code>IsNrMultiplication</code> are a 
group <var>G</var>, a <font face="Gill Sans,Helvetica,Arial">GAP</font>-function <var>mul</var> which has two arguments <code>x</code> and <code>y</code> which
must both be elements of the group <var>G</var> and returns an element <code>z</code> of <var>G</var> s.t.
<var>mul</var> defines a  binary operation on <em>G</em>. As an optional third parameter
<code>IsNrMultiplication</code> accepts a list of control strings <var>lcs</var>.
<p>
<code>IsNearRingMultiplication</code> returns <code>true</code> (<code>false</code>) if <var>mul</var> is (is not) a nearring
multiplication on <var>G</var> i.e. it checks whether it is well-defined, associative
and left distributive over the group operation of <var>G</var>. The list <var>lcs</var> may
contain one or more of the strings <code> "closed" </code>, <code> "ass" </code> and <code> "rdistr" </code>
in which case the according property is not tested. In this case it is
assumed that the user has checked it. This feature should only be used in cases
where it would take too long to check certain laws element by element and the
user is absolutely sure about the correctness.
<p>
<pre>
    gap&gt; G := TWGroup( 24, 6 );
    24/6
    gap&gt; mul_l := function ( x, y ) return y; end;
    function ( x, y ) ... end
    gap&gt; IsNearRingMultiplication( G, mul_l );
    true
    gap&gt; mul_r := function ( x, y ) return x; end;
    function ( x, y ) ... end
    gap&gt; IsNearRingMultiplication( G, mul_r );          
    #I  specified multiplication is not left distributive.
    false
    gap&gt; IsNearRingMultiplication( G, mul_r, ["closed","ldistr"] );
    true
</pre>
<p>
<a name = "SSEC001.2"></a>
<li><code>NearRingMultiplicationByOperationTable( </code><var>G</var><code>, </code><var>table</var><code>, </code><var>elmlist</var><code> )</code>
<p>
The function <code>NearRingMultiplicationByOperationTable</code> returns the nearring
multiplication on the group <var>G</var> which is defined by the multiplication table
<var>table</var>. Rather than group elements the entries of <var>table</var> are the positions
of the group element in the list <var>elmlist</var> (the first element in
<var>elmlist</var> is 1, the second is 2, a.s.o.). Usually the neutral element of the
group will be the first.
<p>
<code>IsNearRingMultiplication</code> can be used to check whether the resulting multiplication
is indeed a nearring multiplication on <var>G</var>.
<p>
<pre>
    gap&gt; G := CyclicGroup( 4 );            
    &lt;pc group of size 4 with 2 generators&gt;
    gap&gt; GeneratorsOfGroup( G );
    [ f1, f2 ]
    gap&gt; a := last[1];
    f1
    gap&gt; Order( a );
    4
    gap&gt; # a generates G indeed
    gap&gt; elmlist := List( [0..3], x -&gt; a^x );
    [ &lt;identity&gt; of ..., f1, f2, f1*f2 ]
    gap&gt; # Let:  1 := identity of ..., 2 := f1, 3 := f2, 4 := f1*f2
    gap&gt; # Consider the following multiplication table on G:
    gap&gt; OT := [[1, 1, 1, 1],
    &gt; [1, 4, 3, 2],                                                   
    &gt; [1, 1, 1, 1],
    &gt; [1, 2, 3, 4]];;
        gap&gt; mul := NearRingMultiplicationByOperationTable( G, OT, elmlist );
    function ( x, y ) ... end
    gap&gt; IsNearRingMultiplication( G, mul );
    true
</pre>
<p>
<p>
<h2><a name="SECT002">2.2 Construction of nearrings</a></h2>
<p><p>
<a name = "SSEC002.1"></a>
<li><code>ExplicitMultiplicationNearRing( </code><var>G</var><code>, </code><var>mul</var><code> )</code>
<p>
The constructor function <code>ExplicitMultiplicationNearRing</code> returns the nearring 
defined by the group <var>G</var> and the nearring multiplication <var>mul</var>.
(For a detailed explanation of <var>mul</var> see Section <a href="CHAP002.htm#SSEC001.1">IsNearRingMultiplication</a>.)
<p>
<code>ExplicitMultiplicationNearRing</code> calls
<code>IsNearRingMultiplication</code> in order to make sure that
<var>mul</var> is really a nearring multiplication. If the nearring
multiplication should not be checked,
<p>
<a name = "SSEC002.2"></a>
<li><code>ExplicitMultiplicationNearRingNC( </code><var>G</var><code>, </code><var>mul</var><code> )</code>
<p>
may be called.
<p>
<pre>
    gap&gt; n := ExplicitMultiplicationNearRing( GTW18_3, mul_l );
    ExplicitMultiplicationNearRing ( 18/3 , multiplication )
    gap&gt; n = ExplicitMultiplicationNearRingNC( GTW18_3, mul_l );
    true
</pre>
<p>
<a name = "SSEC002.3"></a>
<li><code>IsNearRing( </code><var>obj</var><code> )</code>
<p>
<code>IsNearRing</code> returns <code>true</code> if the object <var>obj</var> is a nearring 
and <code>false</code> otherwise. 
<p>
<pre>
    gap&gt; n := ExplicitMultiplicationNearRingNC( GTW18_3, mul_l );
    ExplicitMultiplicationNearRing ( 18/3 , multiplication )
    gap&gt; IsNearRing( n );                                       
    true
    gap&gt; IsNearRing( GroupReduct( n ) );
    false
</pre>
<p>
<a name = "SSEC002.4"></a>
<li><code>IsExplicitMultiplicationNearRing( </code><var>obj</var><code> )</code>
<p>
<code>IsExplicitMultiplicationNearRing</code> returns <code>true</code>, if the object <var>obj</var> is
a nearring defined by a group and a multiplication as with
<a href="CHAP002.htm#SSEC002.1">ExplicitMultiplicationNearRing</a>.
<p>
<pre>
    gap&gt; IsExplicitMultiplicationNearRing( n );
    true
</pre>
<p>
<p>
<h2><a name="SECT003">2.3 Direct products of nearrings</a></h2>
<p><p>
<a name = "SSEC003.1"></a>
<li><code>DirectProductNearRing( </code><var>nr1</var><code>, </code><var>nr2</var><code> )</code>
<p>
Given two nearrings <var>nr1</var> and <var>nr2</var>, the function <code>DirectProductNearRing</code>
constructs the direct product of these.
<p>
<pre>
    gap&gt; n := ExplicitMultiplicationNearRingNC( GTW18_3, mul_l );
    ExplicitMultiplicationNearRing ( 18/3 , multiplication )
    gap&gt; zero_mul := function ( x, y ) return (); end;
    function ( x, y ) ... end
    gap&gt; z := ExplicitMultiplicationNearRingNC( GTW12_3, zero_mul );
    ExplicitMultiplicationNearRing ( 12/3 , multiplication )
    gap&gt; d := DirectProductNearRing( n, z );
    DirectProductNearRing( ExplicitMultiplicationNearRing ( 18/3 , multi\
    plication ), ExplicitMultiplicationNearRing ( 12/3 , multiplication \
    ) )
    gap&gt; IsExplicitMultiplicationNearRing( d );
    true
</pre>
<p>
<p>
<h2><a name="SECT004">2.4 Operation tables for nearrings</a></h2>
<p><p>
<a name = "SSEC004.1"></a>
<li><code>PrintTable( </code><var>nr</var><code> )</code>
<p>
<code>PrintTable</code> prints the additive and multiplicative Cayley tables of the 
nearring <var>nr</var>. This function works the same way as for groups.
<p>
<pre>
    gap&gt; n := ExplicitMultiplicationNearRingNC( CyclicGroup( 3 ), mul_l );
    ExplicitMultiplicationNearRing ( &lt;pc group of size 3 with 
    1 generator&gt; , multiplication )
    gap&gt; SetSymbols( n, ["0","1","2"] );
    gap&gt; PrintTable( n );               
    Let:
    0 := (&lt;identity&gt; of ...)
    1 := (f1)
    2 := (f1^2)

      +  | 0  1  2  
      ------------
      0  | 0  1  2  
      1  | 1  2  0  
      2  | 2  0  1  

      *  | 0  1  2  
      ------------
      0  | 0  1  2  
      1  | 0  1  2  
      2  | 0  1  2  
</pre>
<p>
Optionally, <code>PrintTable</code> can be used in the form <code>PrintTable( </code><var>nr</var><code>, </code><var>mode</var><code> )</code>, 
where <var>mode</var> is a string. If the letter <code>e</code> is contained in this string, the 
definitions of the symbols used are printed, if the letter <code>a</code> is contained 
in the string, the addition table is printed, and if the letter <code>m</code> is contained
in the string, the multiplication table of the nearring is printed. Every 
combination of these three letters in any order is possible.
<p>
<p>
<h2><a name="SECT005">2.5 Modified symbols for the operation tables</a></h2>
<p><p>
<a name = "SSEC005.1"></a>
<li><code>SetSymbols( </code><var>nr</var><code>, </code><var>symblist</var><code> )</code>
<a name = "SSEC005.1"></a>
<li><code>SetSymbolsSupervised( </code><var>nr</var><code>, </code><var>symblist</var><code> )</code>
<p>
The function <code>SetSymbols</code> and <code>SetSymbolsSupervised</code> allow you to define a
list <var>symblist</var> of strings to be used when printing the operation tables of
the nearring. <code>SetSymbols</code> simply sets the set of strings to the given value.
<code>SetSymbolsSupervised</code> checks, if there are more symbols than the nearring has
elements. In this case the superfluous strings are ignored. If there are less
symbols than the nearring has elements, <code>SetSymbolsSupervised</code> ``invents''
unique names for the rest of the elements. In any case a warning is printed.
If there are repetitions or holes in the list <var>symblist</var> an error is signaled.
<p>
<a name = "SSEC005.2"></a>
<li><code>Symbols( </code><var>nr</var><code> )</code>
<p>
allows you to look at the set of symbols, which are currently in use.
<p>
<pre>
    gap&gt; n := LibraryNearRing( GTW3_1, 4 );
    LibraryNearRing(3/1, 4)
    gap&gt; Symbols( n );
    [ "n0", "n1", "n2" ]
    gap&gt; SetSymbolsSupervised( n,
            ["apple", "banana", "coconut", "donut", "potato"] );
    Warning: too many symbols ...ignoring the last 2 symbols
    gap&gt; PrintTable( n, "m" );

            *  | apple    banana   coconut  
      ------------------------------------
      apple    | apple    apple    apple    
      banana   | apple    banana   coconut  
      coconut  | apple    banana   coconut  
</pre>
<p>
<p>
<h2><a name="SECT006">2.6 Accessing nearring elements</a></h2>
<p><p>
The elements of a nearring are different from those of its group reduct.
In order to make group elements and nearring elements distinguishable for the
user, nearring elements are printed with an extra pair of parentheses.
The two functions <code>AsGroupReductElement</code> and <code>AsNearRingElement</code> can be
used to switch between these two representations.
<p>
<a name = "SSEC006.1"></a>
<li><code>AsNearRingElement( </code><var>nr</var><code>, </code><var>grpelm</var><code> )</code>
<p>
returns the representation as a nearring element of an element <var>grpelm</var> of the
group reduct of the nearring <var>nr</var>.
<p>
<a name = "SSEC006.2"></a>
<li><code>AsGroupReductElement( </code><var>nrelm</var><code> )</code>
<p>
returns the representation as an element of the group reduct of the nearring
of the nearring element <var>nrelm</var>.
<p>
<pre>
    gap&gt; mul_l := function ( x, y ) return y; end;              
    function ( x, y ) ... end
    gap&gt; n := ExplicitMultiplicationNearRingNC( GTW6_2, mul_l );
    ExplicitMultiplicationNearRing ( 6/2 , multiplication )
    gap&gt; AsList( n );
    [ (()), ((2,3)), ((1,2)), ((1,2,3)), ((1,3,2)), ((1,3)) ]
    gap&gt; e := AsNearRingElement( n, (2,3) );
    ((2,3))
    gap&gt; e in n;
    true
    gap&gt; f := AsNearRingElement( n, (1,3) );
    ((1,3))
    gap&gt; e + f;
    ((1,3,2))
    gap&gt; e * f;
    ((1,3))
    gap&gt; p := AsGroupReductElement( e );                      
    (2,3)
    gap&gt; IsPerm( p );
    true
    gap&gt; p + p;
    Error no method found for operation SUM with 2 arguments at
    Error( "no method found for operation ", NAME_FUNC( operation ), 
     " with 2 arguments" );
    Entering break read-eval-print loop, you can 'quit;' to quit to outer l\
    oop,
    or you can return to continue
    brk&gt; 
</pre>
<p>
<p>
<h2><a name="SECT007">2.7 Nearring elements</a></h2>
<p><p>
There are three different ways to ask for the elements of a nearring.
<p>
<a name = "SSEC007.1"></a>
<li><code>AsList( </code><var>nr</var><code> )</code>
<p>
The function <code>AsList</code> computes the elements of the nearring <var>nr</var>. It returns
the elements as a list.
<p>
<a name = "SSEC007.2"></a>
<li><code>AsSortedList( </code><var>nr</var><code> )</code>
<p>
does essentially the same, but returns a set of elements.
<p>
<a name = "SSEC007.3"></a>
<li><code>Enumerator( </code><var>nr</var><code> )</code>
<p>
does essentially the same as <code>AsList</code>, but returns an enumerator for the
elements of <var>nr</var>. An enumerator is an object that is capable of enumerating
the elements the nearring one by one. This is especially important if the
nearring is very big and not every element can be stored.
<p>
<pre>
    gap&gt; n := LibraryNearRing( GTW6_2, 39 );                    
    LibraryNearRing(6/2, 39)
    gap&gt; e := Enumerator( n );                                  
    &lt;enumerator of near ring&gt;
    gap&gt; e[1];
    (())
    gap&gt; x := AsNearRingElement( n, (1,2,3) );
    ((1,2,3))
    gap&gt; Position( e, x );
    2
    gap&gt; Length(e);
    6
    gap&gt; l := AsList( n );                                           
    [ (()), ((2,3)), ((1,2)), ((1,2,3)), ((1,3,2)), ((1,3)) ]
    gap&gt; e[3] = l[3];
    false
    gap&gt; AsSortedList( n );                                     
    [ (()), ((2,3)), ((1,2)), ((1,2,3)), ((1,3,2)), ((1,3)) ]
</pre>
<p>
<p>
<h2><a name="SECT008">2.8 Random nearring elements</a></h2>
<p><p>
<a name = "SSEC008.1"></a>
<li><code>Random( </code><var>nr</var><code> )</code>
<p>
<code>Random</code> returns a random element of the nearring <var>nr</var>.
<p>
<pre>
    gap&gt; n := LibraryNearRing( GTW6_2, 39 );                    
    LibraryNearRing(6/2, 39)
    gap&gt; Random(n);
    ((1,3))
</pre>
<p>
<p>
<h2><a name="SECT009">2.9 Nearring generators</a></h2>
<p><p>
<a name = "SSEC009.1"></a>
<li><code>GeneratorsOfNearRing( </code><var>nr</var><code> )</code>
<p>
The function <code>GeneratorsOfNearRing</code> returns a set of (not necessarily
additive) generators of the nearring <var>nr</var>.
<p>
<pre>
    gap&gt; n := ExplicitMultiplicationNearRingNC( GTW8_4, mul_l );
    ExplicitMultiplicationNearRing ( 8/4 , multiplication )
    gap&gt; GeneratorsOfNearRing( n );
    [ ((1,2,3,4)), ((2,4)) ]
</pre>
<p>
<p>
<h2><a name="SECT010">2.10 Size of a nearring</a></h2>
<p><p>
<a name = "SSEC010.1"></a>
<li><code>Size( </code><var>nr</var><code> )</code>
<p>
<code>Size</code> returns the number of elements in the nearring <var>nr</var>.
<p>
<pre>
    gap&gt; n := LibraryNearRingWithOne( GTW24_3, 8 );
    LibraryNearRingWithOne(24/3, 8)
    gap&gt; Size(n);
    24
</pre>
<p>
<p>
<h2><a name="SECT011">2.11 The additive group of a nearring</a></h2>
<p><p>
<a name = "SSEC011.1"></a>
<li><code>GroupReduct( </code><var>nr</var><code> )</code>
<p>
The function <code>GroupReduct</code> returns the nearring <var>nr</var> as a
(multiplicative) group.
<p>
<pre>
    gap&gt; GroupReduct( LibraryNearRingWithOne( GTW24_3, 8 ) );
    24/3
</pre>
<p>
<p>
<h2><a name="SECT012">2.12 Nearring endomorphisms</a></h2>
<p><p>
<a name = "SSEC012.1"></a>
<li><code>Endomorphisms( </code><var>nr</var><code> )</code>
<p>
<code>Endomorphisms</code> computes all the endomorphisms of the nearring <var>nr</var>. 
The endomorphisms are returned as a list of transformations. In fact, the
returned list contains those endomorphisms of the group reduct of <var>nr</var>
which are also nearring endomorphisms.
<p>
<pre>
    gap&gt; Endomorphisms ( LibraryNearRing( GTW12_4, 4 ) ) ;
    [ [ (1,2,4), (2,3,4) ] -&gt; [ (), () ], 
      [ (1,2,4), (2,3,4) ] -&gt; [ (1,2,4), (2,3,4) ] ]
    gap&gt; Length( Endomorphisms( GTW12_4 ) );
    33
</pre>
<p>
<p>
<h2><a name="SECT013">2.13 Nearring automorphisms</a></h2>
<p><p>
<a name = "SSEC013.1"></a>
<li><code>Automorphisms( </code><var>nr</var><code> )</code>
<p>
<code>Automorphisms</code> computes all the automorphisms of the nearring <var>nr</var>. 
The automorphisms are returned as a list of transformations. In fact, the
returned list contains those automorphisms of the group reduct of <var>nr</var>
which are also nearring automorphisms.
<p>
<pre>
    gap&gt; Automorphisms( LibraryNearRing( GTW12_4, 4 ) );
    [ IdentityMapping( 12/4 ) ]
</pre>
<p>
<p>
<h2><a name="SECT014">2.14 Isomorphic nearrings</a></h2>
<p><p>
<a name = "SSEC014.1"></a>
<li><code>IsIsomorphicNearRing( </code><var>nr1</var><code>, </code><var>nr2</var><code> )</code>
<p>
The function <code>IsIsomorphicNearRing</code> returns <code>true</code> if the two nearrings
<var>nr1</var> and <var>nr2</var> are isomorphic and <code>false</code> otherwise.
<p>
<pre>
    gap&gt; IsIsomorphicNearRing( MapNearRing( GTW2_1 ),                       
    &gt; LibraryNearRingWithOne( GTW4_2, 5 ) );
    true
</pre>
<p>
<p>
<h2><a name="SECT015">2.15 Subnearrings</a></h2>
<p><p>
<a name = "SSEC015.1"></a>
<li><code>SubNearRings( </code><var>nr</var><code> )</code>
<p>
The function <code>SubNearRings</code> computes all subnearrings of the nearring 
<var>nr</var>. The function returns a list of nearrings representing the 
according subnearrings.
<p>
<pre>
    gap&gt; n := LibraryNearRing( GTW12_4, 8 );
    LibraryNearRing(12/4, 8)
    gap&gt; SubNearRings( n );
    [ ExplicitMultiplicationNearRing ( Group(()) , multiplication ),
      ExplicitMultiplicationNearRing ( Group([ (1,4)(2,3) ]) , multiplication ),
      ExplicitMultiplicationNearRing ( Group([ (1,2)(3,4) ]) , multiplication ),
      ExplicitMultiplicationNearRing ( Group([ (2,3,4) ]) , multiplication ),
      ExplicitMultiplicationNearRing ( Group([ (1,2,4) ]) , multiplication ),
      ExplicitMultiplicationNearRing ( Group([ (1,3,2) ]) , multiplication ),
      ExplicitMultiplicationNearRing ( Group([ (1,4,3) ]) , multiplication ),
      ExplicitMultiplicationNearRing ( Group([ (1,4)(2,3), (1,3)(2,4)
         ]) , multiplication ), ExplicitMultiplicationNearRing ( Group(
        [ (1,4)(2,3), (1,3)(2,4), (2,3,4) ]) , multiplication ) ]
</pre>
<p>
<p>
<h2><a name="SECT016">2.16 Invariant subnearrings</a></h2>
<p><p>
<a name = "SSEC016.1"></a>
<li><code>InvariantSubNearRings( </code><var>nr</var><code> )</code>
<p>
A subnearring (<i>M</i>,+,&#183;) of a nearring (<i>N</i>,+,&#183;) is called an 
<strong>invariant subnearring</strong> if both, <i>M</i> &#183;<i>N</i> and <i>N</i> &#183;<i>M</i> are subsets of <i>M</i>.
<p>
The function <code>InvariantSubNearRings</code>  computes all invariant 
subnearrings of the nearring <var>nr</var>.
The function returns a list of nearrings representing the according 
invariant subnearrings.
<p>
<pre>
    gap&gt; n := LibraryNearRing( GTW12_4, 8 );
    LibraryNearRing(12/4, 8)
    gap&gt; i := InvariantSubNearRings( n );
    [ ExplicitMultiplicationNearRing ( Group(()) , multiplication ),
      ExplicitMultiplicationNearRing ( Group([ (1,2)(3,4) ]) , multiplication ),
      ExplicitMultiplicationNearRing ( Group([ (2,3,4) ]) , multiplication ),
      ExplicitMultiplicationNearRing ( Group([ (1,4,3) ]) , multiplication ),
      ExplicitMultiplicationNearRing ( Group([ (1,4)(2,3), (1,3)(2,4), (2,3,4)
         ]) , multiplication ) ]
</pre>
<p>
<p>
<h2><a name="SECT017">2.17 Constructing subnearrings</a></h2>
<p><p>
<a name = "SSEC017.1"></a>
<li><code>SubNearRingBySubgroupNC( </code><var>nr</var><code>, </code><var>S</var><code> )</code>
<p>
For a subgroup <var>S</var> of the group reduct of the nearring which is closed
under the multiplication of <var>nr</var> the function
<code>SubNearRingBySubgroupNC</code> returns the subnearRing of <var>nr</var>, which is
induced by this subgroup. The <var>nr</var>-invariance is not explicitely
tested.
<p>
<pre>
    gap&gt; n := LibraryNearRing( GTW12_4, 8 );            
    LibraryNearRing(12/4, 8)
    gap&gt; S := Subgroup( GTW12_4, [ (1,2)(3,4) ] );
    Group([ (1,2)(3,4) ])
    gap&gt; sn := SubNearRingBySubgroupNC( n, S );
    ExplicitMultiplicationNearRing ( Group([ (1,2)(3,4) ]) , multiplication )
</pre>
<p>
<p>
<h2><a name="SECT018">2.18 Intersection of nearrings</a></h2>
<p><p>
<a name = "SSEC018.1"></a>
<li><code>Intersection( </code><var>listofnrs</var><code> )</code>
<p>
computes the intersection of the nearrings in the list <var>listofnrs</var>.
All of the nearrings in <var>listofnrs</var> must be subnearrings of a common
supernearring.
<p>
<pre>
    gap&gt; n := LibraryNearRingWithOne( GTW27_4, 5 );
    LibraryNearRingWithOne(27/4, 5)
    gap&gt; si := Filtered( SubNearRings( n ), s -&gt; Identity( n ) in s );
    [ ExplicitMultiplicationNearRing ( Group(
        [ (1,23,14)(2,13,6)(3,27,22)(4,18,9)(5,20,12)(7,16,26)(8,25,17)(10,21,
            19)(11,24,15) ]) , multiplication ),
      ExplicitMultiplicationNearRing ( Group(
        [ (1,26,27)(2,19,20)(3,14,16)(4,24,25)(5,6,21)(7,22,23)(8,9,11)(10,12,
            13)(15,17,18), (1,22,16)(2,12,21)(3,26,23)(4,17,11)(5,19,13)(6,20,
            10)(7,14,27)(8,24,18)(9,25,15) ]) , multiplication ),
      ExplicitMultiplicationNearRing ( Group(
        [ (1,17,5)(2,22,8)(3,4,12)(6,26,18)(7,11,20)(9,19,23)(10,16,25)(13,14,
            24)(15,21,27), (1,15,6)(2,7,9)(3,25,13)(4,10,14)(5,27,18)(8,20,23)(11,
            19,22)(12,16,24)(17,21,26), (1,2,4)(3,6,11)(5,9,16)(7,13,17)(8,14,
            21)(10,18,22)(12,15,23)(19,24,26)(20,25,27) ]) , multiplication ) ]
    gap&gt; Intersection( si );
    ExplicitMultiplicationNearRing ( Group(
    [ (1,23,14)(2,13,6)(3,27,22)(4,18,9)(5,20,12)(7,16,26)(8,25,17)(10,21,19)(11,
        24,15) ]) , multiplication )
    gap&gt; Size( last );
    3
</pre>
<p>
<p>
<h2><a name="SECT019">2.19 Identity of a nearring</a></h2>
<p><p>
<a name = "SSEC019.1"></a>
<li><code>Identity( </code><var>nr</var><code> )</code>
<p>
<a name = "SSEC019.2"></a>
<li><code>One( </code><var>nr</var><code> )</code>
<p>
The functions <code>Identity</code> and <code>One</code> return the identity of the multiplicative
semigroup of the nearring <var>nr</var> if it exists and <code>fail</code> otherwise.
<p>
<pre>
    gap&gt; n := LibraryNearRing( GTW12_4, 8 );            
    LibraryNearRing(12/4, 8)
    gap&gt; Identity( n );
    fail
    gap&gt; One( n );
    fail
    gap&gt; n := LibraryNearRingWithOne( GTW24_4, 8 ); 
    LibraryNearRingWithOne(24/4, 8)
    gap&gt; Identity( n );
    ((1,2,3,4,5,6)(7,8))
    gap&gt; One( n );
    ((1,2,3,4,5,6)(7,8))
</pre>
<p>
<a name = "SSEC019.3"></a>
<li><code>IsNearRingWithOne( </code><var>nr</var><code> )</code>
<p>
The function <code>IsNearRingWithOne</code> returns <code>true</code> if the nearring was
constructed as a nearring with one and <code>false</code> otherwise. To decide
whether a nearring has an identity use <code>Identity(</code><var>nr</var><code>)=true</code>.
<p>
<pre>
    gap&gt; n := LibraryNearRing( GTW12_4, 8 );             
    LibraryNearRing(12/4, 8)
    gap&gt; IsNearRingWithOne( n );
    false
    gap&gt; n := LibraryNearRingWithOne( GTW24_4, 8 ); 
    LibraryNearRingWithOne(24/4, 8)
    gap&gt; Identity( n );
    ((1,2,3,4,5,6)(7,8))
    gap&gt; IsNearRingWithOne( n );
    false
</pre>
<p>
<p>
<h2><a name="SECT020">2.20 Units of a nearring</a></h2>
<p><p>
<a name = "SSEC020.1"></a>
<li><code>IsNearRingUnit( </code><var>nr</var><code>, </code><var>x</var><code> )</code>
<p>
An element <i>x</i> of a nearring (<i>N</i>,+,&#183;) with identity 1 is called a <hr>unit
if there exists an element <i>y</i> in <i>N</i> such that <i>x</i>&#183;<i>y</i> = <i>y</i>&#183;<i>x</i> = 1.
<p>
The function <code>IsNearRingUnit</code> returns <code>true</code> if <var>x</var> is a unit in <var>nr</var> and
false otherwise.
<p>
<a name = "SSEC020.2"></a>
<li><code>NearRingUnits( </code><var>nr</var><code> )</code>
<p>
<code>NearRingUnits</code> returns the units of the nearring <var>nr</var> either as
 multiplicative group or list.
<p>
<pre>
    gap&gt; n := LibraryNearRingWithOne( GTW24_4, 8 );
    LibraryNearRingWithOne(24/4, 8)
    gap&gt; NearRingUnits( n );    
    [ ((1,2,3,4,5,6)(7,8)), ((1,6,5,4,3,2)(7,8)) ]
</pre>
<p>
<p>
<h2><a name="SECT021">2.21 Distributivity in a nearring</a></h2>
<p><p>
<a name = "SSEC021.1"></a>
<li><code>Distributors( </code><var>nr</var><code> )</code>
<p>
An element <i>x</i> of a nearring (<i>N</i>,+,&#183;) is called a <hr>distributor
if <i>x</i> = (<i>n</i><sub>1</sub> + <i>n</i><sub>2</sub> ) &#183;<i>n</i><sub>3</sub> &#8722; (<i>n</i><sub>1</sub> &#183;<i>n</i><sub>3</sub> + <i>n</i><sub>2</sub> &#183;<i>n</i><sub>3</sub> ) for some elements
<i>n</i><sub>1</sub>, <i>n</i><sub>2</sub>, <i>n</i><sub>3</sub> of <i>N</i>.
<p>
The function <code>Distributors</code> returns a list containing the distributors 
of the nearring <var>nr</var>. 
<p>
<pre>
    gap&gt; n := LibraryNearRing( GTW12_4, 8 );             
    LibraryNearRing(12/4, 8)
    gap&gt; IsNearRingWithOne( n );
    false
    gap&gt; Distributors( n );
    [ (()), ((2,3,4)), ((2,4,3)), ((1,2)(3,4)), ((1,2,3)), ((1,2,4)), 
      ((1,3,2)), ((1,3,4)), ((1,3)(2,4)), ((1,4,2)), ((1,4,3)), 
      ((1,4)(2,3)) ]
</pre>
<p>
<a name = "SSEC021.2"></a>
<li><code>DistributiveElements( </code><var>nr</var><code> )</code>
<p>
An element <i>d</i> of a left nearring (<i>N</i>,+,&#183;) is called a 
<strong>distributive element</strong> if it is also right distributive over all elements,
i.e. &#8704;<i>n</i><sub>1</sub>, <i>n</i><sub>2</sub>  &#8712; <i>N</i>:&nbsp;(<i>n</i><sub>1</sub> + <i>n</i><sub>2</sub> )&#183;<i>d</i> = <i>n</i><sub>1</sub>&#183;<i>d</i> + <i>n</i><sub>2</sub>&#183;<i>d</i>. 
<p>
The function <code>DistributiveElements</code> returns a list containing the 
distributive elements of the nearring <var>nr</var>. 
<p>
<pre>
    gap&gt; n := LibraryNearRing( GTW12_4, 8 );            
    LibraryNearRing(12/4, 8)
    gap&gt; DistributiveElements( n );
    [ (()) ]
</pre>
<p>
<a name = "SSEC021.3"></a>
<li><code>IsDistributiveNearRing( </code><var>nr</var><code> )</code>
<p>
A left nearring <i>N</i> is called <strong>distributive nearring</strong> if its
multiplication is also right distributive.
<p>
The function <code>IsDistributiveNearRing</code> simply checks if all elements
are distributive and returns the according boolean value 
<code>true</code> or <code>false</code>.
<p>
<pre>
    gap&gt; n := LibraryNearRing( GTW12_4, 8 );            
    LibraryNearRing(12/4, 8)
    gap&gt; IsDistributiveNearRing( n );
    false
</pre>
<p>
<p>
<h2><a name="SECT022">2.22 Elements of a nearring with special properties</a></h2>
<p><p>
<a name = "SSEC022.1"></a>
<li><code>ZeroSymmetricElements( </code><var>nr</var><code> )</code>
<p>
Let (<i>N</i>,+,&#183;) be a left nearring and denote by 0 the neutral element 
of (<i>N</i>,+). 
An element <i>n</i> of <i>N</i> is called a <strong>zero-symmetric element</strong> if 0&#183;<i>n</i> = 0. 
<p>
<strong>Remark:</strong> note that in a <strong>left</strong> nearring <i>n</i>&#183;0 = 0 is true for all elements
<i>n</i>.
<p>
The function <code>ZeroSymmetricElements</code> returns a list containing the 
zero-symmetric elements of the nearring <var>nr</var>. 
<p>
<pre>
    gap&gt; n := LibraryNearRing( GTW12_4, 8 );            
    LibraryNearRing(12/4, 8)
    gap&gt; ZeroSymmetricElements( n );
    [ (()), ((2,3,4)), ((2,4,3)), ((1,2)(3,4)), ((1,2,3)), ((1,2,4)), 
      ((1,3,2)), ((1,3,4)), ((1,3)(2,4)), ((1,4,2)), ((1,4,3)), 
      ((1,4)(2,3)) ]
</pre>
<p>
<a name = "SSEC022.2"></a>
<li><code>IdempotentElements( </code><var>nr</var><code> )</code>
<p>
The function <code>IdempotentElements</code> returns a list containing the 
idempotent elements of the multiplicative semigroup of the nearring <var>nr</var>. 
<p>
<pre>
    gap&gt; n := LibraryNearRing( GTW12_4, 8 );            
    LibraryNearRing(12/4, 8)
    gap&gt; IdempotentElements( n );
    [ (()), ((1,4)(2,3)) ]
</pre>
<p>
<a name = "SSEC022.3"></a>
<li><code>NilpotentElements( </code><var>nr</var><code> )</code>
<p>
Let (<i>N</i>,+,&#183;) be a nearring with zero 0. An element <i>n</i> of <i>N</i> is 
called <strong>nilpotent</strong> if there is a positive integer <i>k</i> such that
<i>n</i><sup><i>k</i></sup> = 0.
<p>
The function <code>NilpotentElements</code> returns a list of sublists of length 
2 where the first entry is a nilpotent element <i>n</i> and the second
entry is the smallest <i>k</i> such that <i>n</i><sup><i>k</i></sup> = 0.
<p>
<pre>
    gap&gt; n := LibraryNearRing( GTW12_4, 8 );            
    LibraryNearRing(12/4, 8)
    gap&gt; NilpotentElements( n );
    [ [ (()), 1 ], [ ((2,3,4)), 2 ], [ ((2,4,3)), 2 ], 
      [ ((1,2)(3,4)), 2 ], [ ((1,2,3)), 2 ], [ ((1,2,4)), 2 ], 
      [ ((1,3,2)), 2 ], [ ((1,3,4)), 2 ], [ ((1,4,2)), 2 ], 
      [ ((1,4,3)), 2 ] ]
</pre>
<p>
<a name = "SSEC022.4"></a>
<li><code>QuasiregularElements( </code><var>nr</var><code> )</code>
<p>
Let (<i>N</i>,+,&#183;) be a left nearring. For an element <i>z</i>  &#8712; <i>N</i>, 
denote the right ideal generated by the set {<i>n</i> &#8722; <i>z</i>&#183;<i>n</i> &#124; <i>n</i>  &#8712; <i>N</i>}
by <i>L</i><sub><i>z</i></sub>.
An element <i>z</i> of <i>N</i> is called <strong>quasiregular</strong> if <i>z</i>  &#8712; <i>L</i><sub><i>z</i></sub>.
<p>
The function <code>QuasiregularElements</code> returns a list of all 
quasiregular elements of a nearring <var>nr</var>.
<p>
<pre>
    gap&gt; n := LibraryNearRing( GTW12_4, 8 );            
    LibraryNearRing(12/4, 8)
    gap&gt; QuasiregularElements( n );
    [ (()), ((2,3,4)), ((2,4,3)), ((1,2)(3,4)), ((1,2,3)), ((1,2,4)), 
      ((1,3,2)), ((1,3,4)), ((1,3)(2,4)), ((1,4,2)), ((1,4,3)) ]
</pre>
<p>
<a name = "SSEC022.5"></a>
<li><code>RegularElements( </code><var>nr</var><code> )</code>
<p>
Let (<i>N</i>,+,&#183;) be a nearring. An element <i>n</i> of <i>N</i> is called <strong>regular</strong> if
there is an element <i>x</i> such that <i>n</i>&#183;<i>x</i>&#183;<i>n</i> = <i>n</i>.
<p>
The function <code>RegularElements</code> returns a list of all regular elements of a
nearring <var>nr</var>.
<p>
<pre>
    gap&gt; n := LibraryNearRing( GTW12_4, 8 );            
    LibraryNearRing(12/4, 8)
    gap&gt; RegularElements( n );
    [ (()), ((1,3)(2,4)), ((1,4)(2,3)) ]
</pre>
<p>
<p>
<h2><a name="SECT023">2.23 Special properties of a nearring</a></h2>
<p><p>
<a name = "SSEC023.1"></a>
<li><code>IsAbelianNearRing( </code><var>nr</var><code> )</code>
<p>
A nearring is called <strong>abelian</strong> if its group reduct is abelian.
<p>
The function <code>IsAbelianNearRing</code> returns the according boolean value
<code>true</code> or <code>false</code>.
<p>
<pre>
    gap&gt; n := LibraryNearRing( GTW12_4, 8 );            
    LibraryNearRing(12/4, 8)
    gap&gt; IsAbelianNearRing( n );
    false
</pre>
<p>
<a name = "SSEC023.2"></a>
<li><code>IsAbstractAffineNearRing( </code><var>nr</var><code> )</code>
<p>
A left nearring <i>N</i> is called <strong>abstract affine</strong> if its group reduct is
abelian and its zero-symmetric elements are exactly its distributive
elements.
<p>
The function <code>IsAbstractAffineNearRing</code> returns the according boolean 
value <code>true</code> or <code>false</code>.
<p>
<pre>
    gap&gt; n := LibraryNearRing( GTW12_4, 8 );            
    LibraryNearRing(12/4, 8)
    gap&gt; IsAbstractAffineNearRing( n );
    false
</pre>
<p>
<a name = "SSEC023.3"></a>
<li><code>IsBooleanNearRing( </code><var>nr</var><code> )</code>
<p>
A left nearring <i>N</i> is called <strong>boolean</strong> if all its elements are
idempotent with respect to multiplication.
<p>
The function <code>IsBooleanNearRing</code> simply checks if all elements
are idempotent and returns the according boolean value 
<code>true</code> or <code>false</code>.
<p>
<pre>
    gap&gt; n := LibraryNearRing( GTW12_4, 8 );            
    LibraryNearRing(12/4, 8)
    gap&gt; IsBooleanNearRing( n );
    false
</pre>
<p>
<a name = "SSEC023.4"></a>
<li><code>IsNilNearRing( </code><var>nr</var><code> )</code>
<p>
A nearring <i>N</i> is called <strong>nil</strong> if all its elements are nilpotent.
<p>
The function <code>IsNilNearRing</code> checks if all elements are nilpotent and returns
the according boolean value <code>true</code> or <code>false</code>.
<p>
<pre>
    gap&gt; n := LibraryNearRing( GTW12_4, 8 );            
    LibraryNearRing(12/4, 8)
    gap&gt; IsNilNearRing( n );
    false
</pre>
<p>
<a name = "SSEC023.5"></a>
<li><code>IsNilpotentNearRing( </code><var>nr</var><code> )</code>
<p>
A nearring <i>N</i> is called <strong>nilpotent</strong> if there is a positive integer
<i>k</i>, s.t. <i>N</i><sup><i>k</i></sup> = {0}.
<p>
The function <code>IsNilpotentNearRing</code> tests if
the nearring <var>nr</var> is nilpotent and returns the according boolean value 
<code>true</code> or <code>false</code>.
<p>
<pre>
    gap&gt; n := LibraryNearRing( GTW12_4, 8 );            
    LibraryNearRing(12/4, 8)
    gap&gt; IsNilpotentNearRing( n );
    false
</pre>
<p>
<a name = "SSEC023.6"></a>
<li><code>IsNilpotentFreeNearRing( </code><var>nr</var><code> )</code>
<p>
A nearring <i>N</i> is called <strong>nilpotent free</strong> if its only nilpotent
element is 0.
<p>
The function <code>IsNilpotentFreeNearRing</code> checks if 
0 is the only nilpotent and returns the according boolean value 
<code>true</code> or <code>false</code>.
<p>
<pre>
    gap&gt; n := LibraryNearRing( GTW12_4, 8 );            
    LibraryNearRing(12/4, 8)
    gap&gt; IsNilpotentFreeNearRing( n );
    false
</pre>
<p>
<a name = "SSEC023.7"></a>
<li><code>IsCommutative( </code><var>nr</var><code> )</code>
<p>
A nearring (<i>N</i>,+,&#183;) is called <strong>commutative</strong> if its multiplicative semigroup
is commutative.
<p>
The function <code>IsCommutative</code> returns the according value <code>true</code> or <code>false</code>.
<p>
<pre>
    gap&gt; n := LibraryNearRing( GTW12_4, 8 );            
    LibraryNearRing(12/4, 8)
    gap&gt; IsCommutative( n );
    false
</pre>
<p>
<a name = "SSEC023.8"></a>
<li><code>IsDgNearRing( </code><var>nr</var><code> )</code>
<p>
A nearring (<i>N</i>,+,&#183;) is called <strong>distributively generated (d.g.)</strong> if 
(<i>N</i>,+) is generated additively by the distributive elements of the
nearring.
<p>
The function <code>IsDgNearRing</code> returns the according value <code>true</code> or <code>false</code>
for a nearring <var>nr</var>.
<p>
<pre>
    gap&gt; n := LibraryNearRing( GTW12_4, 8 );            
    LibraryNearRing(12/4, 8)
    gap&gt; IsDgNearRing( n );
    false
</pre>
<p>
<a name = "SSEC023.9"></a>
<li><code>IsIntegralNearRing( </code><var>nr</var><code> )</code>
<p>
A nearring (<i>N</i>,+,&#183;) with zero element 0 is called <strong>integral</strong> if 
it has no zero divisors, i.e. the condition &#8704;<i>n</i><sub>1</sub>,<i>n</i><sub>2</sub>:&nbsp;<i>n</i><sub>1</sub> &#183;<i>n</i><sub>2</sub> = 0 &#8658; <i>n</i><sub>1</sub> = 0 &#8744;<i>n</i><sub>2</sub> = 0 holds.
<p>
The function <code>IsIntegralNearRing</code> returns 
the according value <code>true</code> or <code>false</code> for a nearring <var>nr</var>.
<p>
<pre>
    gap&gt; n := LibraryNearRing( GTW12_4, 8 );            
    LibraryNearRing(12/4, 8)
    gap&gt; IsIntegralNearRing( n );
    false
</pre>
<p>
<a name = "SSEC023.10"></a>
<li><code>IsPrimeNearRing( </code><var>nr</var><code> )</code>
<p>
A nearring (<i>N</i>,+,&#183;) with zero element 0 is called <strong>prime</strong> if 
the ideal { 0 } is a prime ideal.
<p>
The function <code>IsPrimeNearRing</code> checks if <var>nr</var> is a prime nearring
by using the condition <var>for all non-zero ideals</var> <i>I</i>,<i>J</i>:&nbsp;<i>I</i> &#183;<i>J</i>  &#8800; { 0 } and returns the according value <code>true</code> or <code>false</code>.
<p>
<pre>
    gap&gt; n := LibraryNearRing( GTW12_4, 8 );            
    LibraryNearRing(12/4, 8)
    gap&gt; IsPrimeNearRing( n );
    true
</pre>
<p>
<a name = "SSEC023.11"></a>
<li><code>IsQuasiregularNearRing( </code><var>nr</var><code> )</code>
<p>
A nearring <i>N</i> is called <strong>quasiregular</strong> if all its elements are
quasiregular.
<p>
The function <code>IsQuasiregularNearRing</code> simply checks if all elements
of the nearring <var>nr</var> are quasiregular and returns the according 
boolean value <code>true</code> or <code>false</code>.
<p>
<pre>
    gap&gt; n := LibraryNearRing( GTW12_4, 8 );            
    LibraryNearRing(12/4, 8)
    gap&gt; IsQuasiregularNearRing( n );
    false
</pre>
<p>
<a name = "SSEC023.12"></a>
<li><code>IsRegularNearRing( </code><var>nr</var><code> )</code>
<p>
A nearring <i>N</i> is called <strong>regular</strong> if all its elements are regular.
<p>
The function <code>IsRegularNearRing</code> simply checks if all elements
of the nearring <var>nr</var> are regular and returns the according 
boolean value <code>true</code> or <code>false</code>.
<p>
<pre>
    gap&gt; n := LibraryNearRing( GTW12_4, 8 );            
    LibraryNearRing(12/4, 8)
    gap&gt; IsRegularNearRing( n );
    false
</pre>
<p>
<a name = "SSEC023.13"></a>
<li><code>IsNearField( </code><var>nr</var><code> )</code>
<p>
Let (<i>N</i>,+,&#183;) be a nearring with zero 0 and denote by <i>N</i><sup>*</sup> 
the set <i>N</i> &#8722; {0}. N is a <strong>nearfield</strong> if (<i>N</i>,+,&#183;) has an identity and
(<i>N</i><sup>*</sup>,&#183;) is a group.
<p>
The function <code>IsNearField</code> tests if <var>nr</var> has an identity and 
if every non-zero element has a multiplicative inverse and returns
the according value <code>true</code> or <code>false</code>.
<p>
<pre>
     gap&gt; n := LibraryNearRing( GTW12_4, 8 );
     LibraryNearRing(12/4, 8)
     gap&gt; IsNearField( n );                        
     false    
</pre>
<p>
<a name = "SSEC023.14"></a>
<li><code>IsPlanarNearRing( </code><var>nr</var><code> )</code>
<p>
Let (<i>N</i>,+,&#183;) be a left nearring. For <i>a</i>,<i>b</i>  &#8712; <i>N</i> we define <i>a</i>  &#8801; <i>b</i>
iff <i>a</i>&#183;<i>n</i> = <i>b</i>&#183;<i>n</i> for all <i>n</i> &#8712; <i>N</i>. If <i>a</i>  &#8801; <i>b</i>, then <i>a</i> and <i>b</i>
are called <strong>equivalent multipliers</strong>.
A nearring <i>N</i> is called <strong>planar</strong> if &#124; <i>N</i>/<sub> &#8801; </sub> &#124;  &#8805; 3 and if 
for any two non-equivalent multipliers <i>a</i> and <i>b</i> in <i>N</i>, for any <i>c</i> &#8712; <i>N</i>, 
the equation <i>a</i>&#183;<i>x</i> = <i>b</i>&#183;<i>x</i> + <i>c</i> has a unique solution.
<p>
The function <code>IsPlanarNearRing</code> returns the according value <code>true</code> or
<code>false</code> for a nearring <var>nr</var>.
<p>
<pre>
     gap&gt; n := LibraryNearRing( GTW9_2, 90 );
     LibraryNearRing(9/2, 90)
     gap&gt; IsPlanarNearRing( n );     
     true
</pre>
<p>
<a name = "SSEC023.15"></a>
<li><code>IsWdNearRing( </code><var>nr</var><code> )</code>
<p>
A left nearring (<i>N</i>,+,&#183;) is called <strong>weakly divisible</strong> if 
&#8704;<i>a</i>,<i>b</i> &#8712; <i>N</i> &#8707;<i>x</i> &#8712; <i>N</i> : <i>a</i>&#183;<i>x</i>=<i>b</i> or <i>b</i>&#183;<i>x</i>=<i>a</i>. 
<p>
The function <code>IsWdNearRing</code> returns the according value <var>true</var> or <var>false</var> 
for the nearring <var>nr</var>.
<p>
<pre>
     gap&gt; nr := LibraryNearRing( GTW9_1, 185 );
     LibraryNearRing(9/1, 185)
     gap&gt; IsWdNearRing( nr );
     true
</pre>
<p>
<p>
[<a href = "chapters.htm">Up</a>] [<a href ="CHAP001.htm">Previous</a>] [<a href ="CHAP003.htm">Next</a>] [<a href = "theindex.htm">Index</a>]
<P>
<address>SONATA manual<br>October 2022
</address></body></html>