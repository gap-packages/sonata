<html><head><title>[SONATA-tutorial] 4 Nearrings of transformations on groups</title></head>
<body text="#000000" bgcolor="#ffffff">
[<a href = "chapters.htm">Up</a>] [<a href ="CHAP003.htm">Previous</a>] [<a href ="CHAP005.htm">Next</a>] [<a href = "theindex.htm">Index</a>]
<h1>4 Nearrings of transformations on groups</h1><p>
<p>
We are going to study transformations on the alternating group on four elements
<i>A</i><sub>4</sub>.
<p>
<strong>The problem</strong>: Let <var>T</var> be the nearring of mappings from <i>A</i><sub>4</sub> to <i>A</i><sub>4</sub>
        generated by the single mapping <var>t</var> which maps (2,3,4) to (2,4,3),
        (2,4,3) to (1,2)(3,4), (1,2)(3,4) to (1,2,3), (1,2,3) back to (2,3,4)
        and all other elements of <i>A</i><sub>4</sub> to the neutral element (). Then,
        how many mappings are there in <var>T</var> that have (1,2,3) as a fixed point?
        If there are only a few we would be interested in a list of all of
        these.
<p>
<strong>The solution</strong>:  <br>
        The first thing to do is create the nearring <var>T</var>. So we start with
        the group <i>A</i><sub>4</sub>, which can easily be constructed with the command
<pre>
    gap&gt; A4 := AlternatingGroup( 4 );
    Alt( [ 1 .. 4 ] )
</pre>
        The result is an object which represents the group <i>A</i><sub>4</sub>. If we want
        to see its elements we have to ask <font face="Gill Sans,Helvetica,Arial">GAP</font> to make a list of elements
        out of the group.
<pre>
    gap&gt; AsSortedList( A4 );                                       
    [ (), (2,3,4), (2,4,3), (1,2)(3,4), (1,2,3), (1,2,4), (1,3,2),
     (1,3,4), (1,3)(2,4), (1,4,2), (1,4,3), (1,4)(2,3) ]
</pre>
        Now we create the mapping <var>t</var>. We use the function
        <code>MappingByPositionList</code> to enter it.
<pre>
    t := EndoMappingByPositionList( A4, [1,3,4,5,2,1,1,1,1,1,1,1] );
    &lt;mapping: AlternatingGroup( [ 1 .. 4 ] ) -&gt; AlternatingGroup( 
    [ 1 .. 4 ] ) &gt;
</pre>
        For <code>Mappings</code> the usual operations <code>+</code> and
        <code>*</code> can be used to add and multiply them.
<pre>
    gap&gt; t+t;
    &lt;mapping: AlternatingGroup( [ 1 .. 4 ] ) -&gt; AlternatingGroup( 
    [ 1 .. 4 ] ) &gt;
    gap&gt; last * t;
    &lt;mapping: AlternatingGroup( [ 1 .. 4 ] ) -&gt; AlternatingGroup( 
    [ 1 .. 4 ] ) &gt;
</pre>
        (Recall that <code>last</code> stands for the result of the last computation, in
        this case this is <code>t + t</code>). 
        Now we can construct the nearring. We use the function
        <code>TransformationNearRingByGenerators</code> which asks for the group (<i>A</i><sub>4</sub>)
        and a list of generating elements (the list with <var>t</var> as the only entry)
        as arguments.
<pre>
    gap&gt; T := TransformationNearRingByGenerators( A4, [ t ] );;
</pre>
        Nearrings, allthough generated by a single element can become rather
        big. Before we print out all elements we ask for the size of <var>T</var>.
<pre>
    gap&gt; Size( T );
    20736
</pre>
        It seems reasonable not to print all elements. <strong>Note</strong> that they are
        not even computed, yet. All we wanted to know was the size of <var>T</var> and
        this can be computed without generating all elements. But, yes, we
        could generate them with <code>AsList</code> or <code>AsSortedList</code>. At last we want
        to find out how many of these 20736 <code>GroupTransformations</code> have (1,2,3)
        as a fixed point. We filter them out, but we use a second semicolon at
        the end to suppress printing, because there might be a lot of them.
        Then we ask for the length of the resulting list <var>F</var> of mappings.
<pre>
    gap&gt; F := Filtered( T, tfm -&gt; Image( tfm, (1,2,3) ) = (1,2,3) );;
    gap&gt; Length( F );
    1728
</pre>
        It seems not to be worth printing the whole list. But we could for
        example choose a random transformation from this list <var>F</var> for testing
        purposes.
<pre>
    gap&gt; Random( F );;
</pre>
        There are of course other properties of the nearring <var>T</var>
        which might be interesting. It is clear that a nearring which is
        generated by a single element is not necessarily abelian. <var>T</var> is a
        counterexample. As for finding counterexamples, SONATA can be used
        as a research tool.
<pre>
    gap&gt; IsCommutative( T );
    false
</pre>
        Finally, we try to disprove the conjecture that every transformation
        nearring on an abelian group that is generated by a single element 
        must be commutative.
<pre>
    gap&gt; g := CyclicGroup(2);;
    gap&gt; m := MapNearRing(g);;
    gap&gt; Filtered( m, n -&gt; not( IsCommutative(                                            
    &gt;        TransformationNearRingByGenerators( g, [n] ) ) ) );
    gap&gt; [ &lt;mapping: Group( [ f1 ] ) -&gt; Group( [ f1 ] ) &gt;, 
           &lt;mapping: Group( [ f1 ] ) -&gt; Group( [ f1 ] ) &gt; ]
    gap&gt; GraphOfMapping(last[1]);
    [ [ &lt;identity&gt; of ..., f1 ], [ f1, &lt;identity&gt; of ... ] ]
</pre>
<p>
<p>
[<a href = "chapters.htm">Up</a>] [<a href ="CHAP003.htm">Previous</a>] [<a href ="CHAP005.htm">Next</a>] [<a href = "theindex.htm">Index</a>]
<P>
<address>SONATA-tutorial manual<br>October 2018
</address></body></html>